# Сортировка пузырьком

https://www.geeksforgeeks.org/binary-search/

Сортировка пузырьком является самым простым алгоритмом сортировки. Его работа заключается в многократном обмене соседних элементов массива, которые стоят в неправильном порядке.

**Примеры:**

*Первый проход по массиву:*
```
( 5 1 4 2 8 ) –> ( 1 5 4 2 8 ), Здесь алгоритм сравнивает два первых элемента и меняет их местами, т.к. 5 > 1.
( 1 5 4 2 8 ) –>  ( 1 4 5 2 8 ), Затем меняет местами следующие два элемента 5 > 4
( 1 4 5 2 8 ) –>  ( 1 4 2 5 8 ), Еще один обмен, т.к. 5 > 2
( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ), Т.к. здесь элементы расположены в нужном порядке (8 > 5), алгоритм не меняет их.
```

*Второй проход по массиву:*
```
( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ), первые два элемента стоят в нужно порядке и обменя не происходит
( 1 4 2 5 8 ) –> ( 1 2 4 5 8 ), Здесь происходит обмен, т.к. 4 > 2
( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )
( 1 2 4 5 8 ) –>  ( 1 2 4 5 8 )
Сейчас наш массив отсортирован, но алгоритм еще не знает об этом. Чтобы он завершился, ему нужно пройти по массиву еще один раз без обмена элементами.
```

*Третий проход по массиву:*
```
( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )
( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )
( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )
( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )
```

**Иллюстрация**

![иллюстрация иллюстрация](https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2014/02/bubble-sort1.png)

**Сложность алгоритма:** О(n<sup>2</sup>).

**Вспомогательная память:** O(1)

**Граничные случаи:** Для сортировки вставками требуется максимальное время, если элементы отсортированы в обратном порядке. И требуется минимальное время(n), когда элементы уже отсортированы.

**Сортировка на месте:** Да

**Оптимизация:**

Обычно алгоритм работает за время O(n^2) даже если массив уже отсортирован. Его можно опимизировать: останавливая алгоритм во внутреннем цикле, если бельше нет элементов для обмена.

```
def bubbleSort(arr): 
    n = len(arr) 
   
    for i in range(n): 
        swapped = False
  
        for j in range(0, n-i-1): 
   
            if arr[j] > arr[j+1] : 
                arr[j], arr[j+1] = arr[j+1], arr[j] 
                swapped = True
  
        # Если больше нету двух элементов для обмена во внутреннем цикле,
        # завершаем дальнейшую работу алгоритма
        if swapped == False: 
            break
```
