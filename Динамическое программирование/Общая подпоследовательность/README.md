# Самая длинная общая подпоследовательность

https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/

Постановка задачи LCS: Имеется две последовательности, найдите длину самой длинной подпоследовательности, присутствующей в обеих из них. Подпоследовательность - это последовательность, которая появляется в том же порядке, но не обязательно является смежной. Например, `abc`, `abg`, `bdf`, `aeg`, `acefg` и т. Д. Являются подпоследовательностями последовательности `abcdefg`.

Чтобы выяснить сложность подхода полного перебора, нам нужно сначала узнать количество возможных различных подпоследовательностей строки с длиной `n`, т. е. Найдем количество подпоследовательностей с длинами в диапазоне от `1,2, .. n-1`. Из теории перестановок и комбинаций знаем, что число комбинаций с 1 элементом равно C<sub>n</sub><sup>1</sup>. Количество комбинаций с 2 ​​элементами: C<sub>n</sub><sup>1</sup> и так далее, и так далее. Мы знаем, что C<sub>n</sub><sup>1</sup> + C<sub>n</sub><sup>2</sup> +… C<sub>n</sub><sup>n</sup> = 2n. Таким образом, строка длины n имеет `2n-1` различных возможных подпоследовательностей, так как мы не рассматриваем подпоследовательность с длиной n. Это подразумевает, что временная сложность полного перебора будет O (n<sup>2n</sup>). Обратите внимание, что требуется O(n) времени, чтобы проверить, является ли подпоследовательность общей для обеих строк. Эта временная сложность может быть улучшена с помощью динамического программирования.

Это классическая проблема информатики, основа `diff` (программа сравнения файлов, которая выводит различия между двумя файлами) и имеет приложения в биоинформатике.

Примеры:

- LCS для входных последовательностей `ABCDGH` и `AEDFHR` - это `ADH` длины 3.
- LCS для входных последовательностей `AGGTAB` и `GXTXAYB` - это `GTAB` длины 4.

Простым решением этой проблемы является генерация всех подпоследовательностей обеих заданных последовательностей и поиск самой длинной совпадающей подпоследовательности. Это решение является экспоненциальным с точки зрения сложности времени. Давайте посмотрим, как эта проблема обладает обоими важными свойствами задачи динамического программирования (ДП).

1. Оптимальная подструктура:

    Пусть входными последовательностями являются `X[0..m-1]` и `Y[0..n-1]` длин m и n соответственно. И пусть `L(X[0..m-1], Y[0..n-1])` будет длиной LCS двух последовательностей X и Y. Ниже приводится рекурсивное определение `L(X[0 .. m-1], Y[0..n-1])`.
    
    Если последние символы обеих последовательностей совпадают `X[m-1] == Y[n-1]`, то
    `L(X[0..m-1], Y[0..n-1]) = 1 + L(X[0..m-2], Y[0..n-2])`
    
    Если последние символы обеих последовательностей не совпадают  `X[m-1]! = Y[n-1]`, то
    `L(X[0..m-1], Y[0..n-1]) = MAX(L(X[0..m-2], Y[0..n-1]), L(X[0..m-1], Y[0..n-2]))`
    
    Примеры:
    - Рассмотрим входные строки `AGGTAB` и `GXTXAYB`. Последние символы совпадают для строк. Таким образом, длина LCS может быть записана как:
    `L('AGGTAB', 'GXTXAYB') = 1 + L('AGGTA', 'GXTXAY')`
    
    ![иллюстрация иллюстрация](https://www.geeksforgeeks.org/wp-content/uploads/Longest-Common-Subsequence.png)
    
    - Рассмотрим входные строки `ABCDGH` и `AEDFHR`. Последние символы не совпадают для строк. Таким образом, длина LCS может быть записана как:
    `L('ABCDGH', 'AEDFHR') = MAX(L('ABCDG', 'AEDFHR'), L('ABCDGH', 'AEDFH'))`
    
    Таким образом, проблема LCS обладает оптимальным свойством субструктуры, поскольку основная проблема может быть решена с помощью решений подзадач.

2. Перекрывающиеся подзадачи:

    Ниже приводится простая рекурсивная реализация проблемы LCS. Реализация просто следует рекурсивной структуре, упомянутой выше.
    ```c++
    using namespace std; 
      
    int lcs( char *X, char *Y, int m, int n ) {  
        if (m == 0 || n == 0)  
            return 0;  
        if (X[m-1] == Y[n-1])  
            return 1 + lcs(X, Y, m-1, n-1);  
        else
            return max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n));  
    }   
      
    int main() {  
        char X[] = "AGGTAB";  
        char Y[] = "GXTXAYB";  
          
        int m = strlen(X);  
        int n = strlen(Y);  
          
        cout<<"Length of LCS is "<< lcs( X, Y, m, n ) ;  
          
        return 0;  
    } 
    ```

    Временная сложность описанного выше простого рекурсивного подхода в худшем случае составляет O(2<sup>n</sup>), а худший случай возникает, когда все символы X и Y не совпадают, т. е. Длина LCS равна 0.
    Учитывая вышеописанную реализацию, ниже приведено дерево частичной рекурсии для входных строк «AXYT» и «AYZX».

    ```                             
                                    lcs ("AXYT", "AYZX")
                                 /                       \
               lcs ("AXY", "AYZX")                         lcs ("AXYT", "AYZ")
               /              \                              /            \
    lcs ("AX", "AYZX")      lcs ("AXY", "AYZ")    lcs ("AXY", "AYZ")      lcs ("AXYT", "AY")
    ```

В приведенном выше дереве частичной рекурсии lcs («AXY», «AYZ») решается дважды. Если мы нарисуем полное дерево рекурсии, то увидим, что есть много подзадач, которые решаются снова и снова. Таким образом, эта проблема имеет свойство «Перекрывающаяся подструктура», и повторного вычисления тех же подзадач можно избежать, используя Memoization или Tabulation. 
